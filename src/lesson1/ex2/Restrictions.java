package lesson1.ex2;

public class Restrictions {
    //пара интересных примеров
}

//Нельзя создавать экземпляр по параметру типа.

class Gen<T> {
//    T оb;
//
//    Gen() {
//        оb = new Т(); // Недопустимо
//    }
}

// Ограничения на статические члены

//Никакой stаtiс член не может использовать тип параметра, объявленный в eго классе.
// Например, все stаtiс члены этого класса являются недопустимыми:

class Wrong<T> {
    // Неверно, нельзя создать статические переменные типа Т.
//    static Т оb;

    // Неверно, ни один статический метод не может использовать Т.
//    static T getOb() {
//        return оb;
//    }
}
// объявить статические обобщенные методы со своими параметрами типа все же можно.

// Ограничения на обобщенные массивы.

// Нельзя создать экземпляр массива, тип элемента которого определяется параметром типа.

class Gen2<T extends Number> {
    private T ob;
    private T[] vals; // ОК

    Gen2(T o, T[] nums) {
        ob = o;
        // Этот оператор неверен.
        //vals = new Т[10]; // нельзя создавать массив объектов Т
        // Однако этот оператор верен.
        vals = nums; // можно присвоить ссылку существующему массиву
    }
}
// Нельзя создать массив специфических для типа обобщенных ссылок:

class GenArrays {
    public static void main(String[] args) {
        Integer[] n = {1, 2, 3, 4, 5};
        // Нельзя создать массив специфичных для типа обобщенных ссылок.
        //Gen2<Integer> gens[] = new Gen2<Integer>[10]; // Неверно!
        // Это верно.
        Gen2<?>[] gen = new Gen2<?>[10]; // ОК
        //gens[0] = new Gen2<>(34, n);
    }
}
